
Roger's thoughts:
import math

//simple point class x and y. also a __eq__ for comparing two points

class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y
    
    def __eq__(self, other) : 
        return self.__dict__ == other.__dict__
 
//Move Class will hold dist to goal, moveid (1,2,3,4), and point its moving to
// 1 is forward
// 2 is right
// 3 is left
// 4 is back

class Move:
  def __init__(self, dist, move, point):
    self.dist = dist
    self.move = move
    self.point = point
    
  def __repr__(self):
    return "[" + str(self.dist) + ", " + str(self.move) + "]"

//these all get inistialized by project data given
start = Point(x, y) 
goal = Point(x, y)
curr = Point(x, y)
obstacle = Point(x, y)

//distance in meters for each tile
tileDist = .305 

obstacleArr = []
pathArr = []
possibleMoves = []
visitedPoints = []


*****************This to run it? idk if python needs a main() function?**********************

pathArr = makePath(star, goal, curr, pathArr)
executePath(pathArr)

******************************************************************************************

// This is how to make the path
def makePath(start, goal, curr)
  curr = start
  visitedPoints.append(curr)
  
  while curr != goal:
    pathArr.append(findNextMove(curr))
    curr = getPoint(curr, pathArr[-1])
    visitedPoints.append(curr)
    
return pathArr
        
_______________________________________________________________________

// 1 is forward
// 2 is right
// 3 is left
// 4 is back

def findNextMove(curr)
  for i in range(1,5):
    possibleMovePoints.append(getPoint(curr, i)) //will create 4 points (one for each possible move)
  
  moveId = 1
  for point in posbbileMovePoints:
    move = Move(distBetweenPoints(point, goal), moveId, point)
    movesArr.append(move) // this will end up hold all moves distances from goal and the move identifier (1,2,3,4), and point its going to
    moveId += 1
    
  movesArr.sort(key=lambda x: x.dist); // this will now hold sorted move options with shortest being at movesArr[0]
  
  bestMove = getBestMove(movesArr)
  
  //return best move option
  return bestMove 
____________________________________________________________________________

def getBestMove(movesArr):
  //TODO need to implement bestMove to take based on obstacles check and 
  //no visiting repeat points, movesArr contains shortest path, move id, and point its going to 
  //in order from shortest distance at movesArr[0] and longest at movesArr[3]
  return bestMove
  
  
def getPoint(curr, move):
  if move == 1: //forward
    curr.x += tileDist
  elif move == 2: //right
    curr.y -= tileDist
  elif move == 3: //left
    curr.y += tileDist
  elif move == 4: //back
    curr.x -= tileDist
  return curr



def distBetweenPoints(pointA, pointB)
  dist = math.hypot(pointA.x - pointB.x, pointA.y - pointB.y)
  return dist


_______________________________________________________________________

// This is how to execute a path created that is stored in an array
// 1 is forward
// 2 is right
// 3 is left
// 4 is back

def executePath(pathArr):
  for move in pathArr
    match move:
      case 1:
        MoveForward();
      case 2:
        RightTurn();
        MoveForward();
      case 3:
        LeftTurn();
        MoveForward();
      case 4:
      RightTurn();
      RightTurn();
      MoveForward();
    
